#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨
#           This file was automatically generated from src/transformers/models/qwen3_moe/modular_qwen3_moe.py.
#               Do NOT edit this file manually as any edits will be overwritten by the generation of
#             the file from the modular. If any change should be done, please apply the change to the
#                          modular_qwen3_moe.py file directly. One of our CI enforces this.
#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨
# coding=utf-8
# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.
# Copyright 2023 DeepSeek-AI and The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""" PyTorch Qwen3_MOE model."""
import os
import math
import warnings
from typing import List, Optional, Tuple, Union

import torch
import torch.nn.functional as F
import torch.utils.checkpoint
from torch import nn
from torch.nn import BCEWithLogitsLoss, CrossEntropyLoss, MSELoss
from torch.distributed.distributed_c10d import _world

import torch_npu
import torchair
torchair.patch_for_hcom()

from mindspeed.ops import gmm
import torch.distributed as dist
import numpy as np

from transformers.activations import ACT2FN
from transformers.cache_utils import Cache, DynamicCache
from transformers.modeling_utils import PreTrainedModel
from transformers.pytorch_utils import (
    ALL_LAYERNORM_LAYERS,
    is_torch_greater_or_equal_than_1_13,
)
from transformers.utils import (
    add_start_docstrings,
    add_start_docstrings_to_model_forward,
    logging,
)
from .configuration_qwen3_moe import Qwen3MoeConfig
from .global_setting import _OPTIMIZER_SETTING

logger = logging.get_logger(__name__)

_CONFIG_FOR_DOC = "Qwen3MoeConfig"

class Qwen3MoeRMSNorm(nn.Module):
    def __init__(self, hidden_size, eps=1e-6):
        """
        Qwen3MoeRMSNorm is equivalent to T5LayerNorm
        """
        super().__init__()
        self.weight = nn.Parameter(torch.ones(hidden_size))
        self.variance_epsilon = eps

    def ln(self, hidden_states):
        input_dtype = hidden_states.dtype
        hidden_states = hidden_states.to(torch.float32)
        variance = hidden_states.pow(2).mean(-1, keepdim=True)
        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)
        return self.weight * hidden_states.to(input_dtype)

    def ln_npu(self, hidden_states):
        result = torch_npu.npu_rms_norm(hidden_states, self.weight, self.variance_epsilon)[0]
        return result

    def __forward(self, hidden_states, *args):
        if len(args) == 0:
            return self.ln_npu(hidden_states)
        else:
            return self.ln_npu(hidden_states), hidden_states

    def forward(self, hidden_states, *args):
        if len(args) == 0: # only hidden_states exists
            result = self.ln_npu(hidden_states)
            return result
        elif len(args) == 1 and args[0] is None: # residual is None
            result = self.ln_npu(hidden_states)
            residual = hidden_states
            return (result, residual)
        elif len(args) == 1: # residual is not None
            residual = args[0]
            y, _, x = torch_npu.npu_add_rms_norm(residual, hidden_states, self.weight, self.variance_epsilon)
            return (y, x)
        else:
            raise NotImplementedError(
                f"insupportable Qwen3MoeRMSNorm for input_args len as (include hid): {len(args) + 1}"
            )


ALL_LAYERNORM_LAYERS.append(Qwen3MoeRMSNorm)


class Qwen3MoeRotaryEmbedding(nn.Module):
    def __init__(self, config, dim, max_position_embeddings=2048, base=10000, device=None):
        super().__init__()
        self.config = config
        self.dim = dim
        self.max_position_embeddings = max_position_embeddings
        self.base = base
        inv_freq = 1.0 / (
            self.base ** (torch.arange(0, self.dim, 2).float().to(device) / self.dim)
        )
        self.register_buffer("inv_freq", inv_freq, persistent=False)

        # Build here to make `torch.jit.trace` work.
        self._set_cos_sin_cache(
            seq_len=max_position_embeddings,
            device=self.inv_freq.device,
            dtype=torch.get_default_dtype(),
        )

    def _set_cos_sin_cache(self, seq_len, device, dtype):
        self.max_seq_len_cached = seq_len
        t = torch.arange(
            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype
        )

        freqs = torch.outer(t, self.inv_freq.to(t.device))
        # Different from paper, but it uses a different permutation in order to obtain the same calculation
        emb = torch.cat((freqs, freqs), dim=-1)
        self.register_buffer("cos_cached", emb.cos().to(dtype), persistent=False)
        self.register_buffer("sin_cached", emb.sin().to(dtype), persistent=False)

    def __forward(self, x, kv_len=None):
        # x shape is [bs, num_attention_heads, seq_len, head_size]
        if self.max_seq_len_cached is None or kv_len > self.max_seq_len_cached:
            self._set_cos_sin_cache(seq_len=kv_len, device=x.device, dtype=x.dtype)

        return (
            self.cos_cached[:kv_len].to(dtype=x.dtype),
            self.sin_cached[:kv_len].to(dtype=x.dtype),
        )

    def forward(self, x, seq_len, kv_len, max_seq_len=None):
        # x shape is [bs, num_attention_heads, seq_len, head_size]
        if max_seq_len is None:
            self._set_cos_sin_cache(seq_len=kv_len, device=x.device, dtype=x.dtype)
        elif max_seq_len > self.max_seq_len_cached:
            self._set_cos_sin_cache(seq_len=max_seq_len, device=x.device, dtype=x.dtype)
        
        batch_size, _, _ = x.size()
        if seq_len == 1:
            # BD -> BNSD
            cos = torch.index_select(self.cos_cached, dim=0, index=kv_len).unsqueeze(1).unsqueeze(1)
            sin = torch.index_select(self.sin_cached, dim=0, index=kv_len).unsqueeze(1).unsqueeze(1)
        else:
            # SD -> BSND
            cos = self.cos_cached[:seq_len].unsqueeze(0).unsqueeze(2).repeat(batch_size, 1, 1, 1)
            sin = self.sin_cached[:seq_len].unsqueeze(0).unsqueeze(2).repeat(batch_size, 1, 1, 1)

        return (
            cos.to(dtype=x.dtype),
            sin.to(dtype=x.dtype),
        )


# Copied from transformers.models.llama.modeling_llama.LlamaLinearScalingRotaryEmbedding with Llama->Qwen3Moe
class Qwen3MoeLinearScalingRotaryEmbedding(Qwen3MoeRotaryEmbedding):
    """Qwen3MoeRotaryEmbedding extended with linear scaling. Credits to the Reddit user /u/kaiokendev"""

    def __init__(
        self,
        config,
        dim,
        max_position_embeddings=2048,
        base=10000,
        device=None,
        scaling_factor=1.0,
    ):
        self.scaling_factor = scaling_factor
        super().__init__(config, dim, max_position_embeddings, base, device)

    def _set_cos_sin_cache(self, seq_len, device, dtype):
        self.max_seq_len_cached = seq_len
        t = torch.arange(
            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype
        )
        t = t / self.scaling_factor

        freqs = torch.outer(t, self.inv_freq)
        # Different from paper, but it uses a different permutation in order to obtain the same calculation
        emb = torch.cat((freqs, freqs), dim=-1)
        self.register_buffer("cos_cached", emb.cos().to(dtype), persistent=False)
        self.register_buffer("sin_cached", emb.sin().to(dtype), persistent=False)


# Copied from transformers.models.llama.modeling_llama.LlamaDynamicNTKScalingRotaryEmbedding with Llama->Qwen3Moe
class Qwen3MoeDynamicNTKScalingRotaryEmbedding(Qwen3MoeRotaryEmbedding):
    """
    Qwen3MoeRotaryEmbedding extended with Dynamic NTK scaling. 
    Credits to the Reddit users /u/bloc97 and /u/emozilla
    """

    def __init__(
        self,
        config,
        dim,
        max_position_embeddings=2048,
        base=10000,
        device=None,
        scaling_factor=1.0,
    ):
        self.scaling_factor = scaling_factor
        super().__init__(config, dim, max_position_embeddings, base, device)

    def _set_cos_sin_cache(self, seq_len, device, dtype):
        self.max_seq_len_cached = seq_len

        if seq_len > self.max_position_embeddings:
            base = self.base * (
                (self.scaling_factor * seq_len / self.max_position_embeddings)
                - (self.scaling_factor - 1)
            ) ** (self.dim / (self.dim - 2))
            inv_freq = 1.0 / (
                base ** (torch.arange(0, self.dim, 2).float().to(device) / self.dim)
            )
            self.register_buffer("inv_freq", inv_freq, persistent=False)

        t = torch.arange(
            self.max_seq_len_cached, device=device, dtype=self.inv_freq.dtype
        )

        freqs = torch.outer(t, self.inv_freq)
        # Different from paper, but it uses a different permutation in order to obtain the same calculation
        emb = torch.cat((freqs, freqs), dim=-1)
        self.register_buffer("cos_cached", emb.cos().to(dtype), persistent=False)
        self.register_buffer("sin_cached", emb.sin().to(dtype), persistent=False)


# Inverse dim formula to find dim based on number of rotations
def yarn_find_correction_dim(
    num_rotations, dim, base=10000, max_position_embeddings=2048
):
    return (dim * math.log(max_position_embeddings / (num_rotations * 2 * math.pi))) / (
        2 * math.log(base)
    )


# Find dim range bounds based on rotations
def yarn_find_correction_range(
    low_rot, high_rot, dim, base=10000, max_position_embeddings=2048
):
    low = math.floor(
        yarn_find_correction_dim(low_rot, dim, base, max_position_embeddings)
    )
    high = math.ceil(
        yarn_find_correction_dim(high_rot, dim, base, max_position_embeddings)
    )
    return max(low, 0), min(high, dim - 1)  # Clamp values just in case


def yarn_get_mscale(scale=1, mscale=1):
    if scale <= 1:
        return 1.0
    return 0.1 * mscale * math.log(scale) + 1.0


def yarn_linear_ramp_mask(min, max, dim):
    if min == max:
        max += 0.001  # Prevent singularity

    linear_func = (torch.arange(dim, dtype=torch.float32) - min) / (max - min)
    ramp_func = torch.clamp(linear_func, 0, 1)
    return ramp_func


class Qwen3MoeYarnRotaryEmbedding(Qwen3MoeRotaryEmbedding):

    def __init__(
        self,
        config,
        dim,
        max_position_embeddings=2048,
        base=10000,
        device=None,
        scaling_factor=1.0,
        original_max_position_embeddings=4096,
        beta_fast=32,
        beta_slow=1,
        mscale=1,
        mscale_all_dim=0,
    ):
        self.scaling_factor = scaling_factor
        self.original_max_position_embeddings = original_max_position_embeddings
        self.beta_fast = beta_fast
        self.beta_slow = beta_slow
        self.mscale = mscale
        self.mscale_all_dim = mscale_all_dim
        super().__init__(config, dim, max_position_embeddings, base, device)

    def _set_cos_sin_cache(self, seq_len, device, dtype):
        self.max_seq_len_cached = seq_len
        dim = self.dim

        freq_extra = 1.0 / (
            self.base
            ** (torch.arange(0, dim, 2, dtype=torch.float32, device=device) / dim)
        )
        freq_inter = 1.0 / (
            self.scaling_factor
            * self.base
            ** (torch.arange(0, dim, 2, dtype=torch.float32, device=device) / dim)
        )

        low, high = yarn_find_correction_range(
            self.beta_fast,
            self.beta_slow,
            dim,
            self.base,
            self.original_max_position_embeddings,
        )
        inv_freq_mask = 1.0 - yarn_linear_ramp_mask(low, high, dim // 2).to(
            device=device, dtype=torch.float32
        )
        inv_freq = freq_inter * (1 - inv_freq_mask) + freq_extra * inv_freq_mask
        self.register_buffer("inv_freq", inv_freq, persistent=False)

        t = torch.arange(seq_len, device=device, dtype=torch.float32)

        freqs = torch.outer(t, inv_freq)

        _mscale = float(
            yarn_get_mscale(self.scaling_factor, self.mscale)
            / yarn_get_mscale(self.scaling_factor, self.mscale_all_dim)
        )

        emb = torch.cat((freqs, freqs), dim=-1)
        self.register_buffer(
            "cos_cached", (emb.cos() * _mscale).to(dtype), persistent=False
        )
        self.register_buffer(
            "sin_cached", (emb.sin() * _mscale).to(dtype), persistent=False
        )


# Copied from transformers.models.llama.modeling_llama.rotate_half
def rotate_half(x):
    """Rotates half the hidden dims of the input."""
    x1 = x[..., : x.shape[-1] // 2]
    x2 = x[..., x.shape[-1] // 2 :]
    return torch.cat((-x2, x1), dim=-1)


# Copied from transformers.models.llama.modeling_llama.apply_rotary_pos_emb
def apply_rotary_pos_emb(q, k, cos, sin, position_ids, unsqueeze_dim=1):
    """Applies Rotary Position Embedding to the query and key tensors.

    Args:
        q (`torch.Tensor`): The query tensor.
        k (`torch.Tensor`): The key tensor.
        cos (`torch.Tensor`): The cosine part of the rotary embedding.
        sin (`torch.Tensor`): The sine part of the rotary embedding.
        position_ids (`torch.Tensor`):
            The position indices of the tokens corresponding to the query and key tensors. For example, this can be
            used to pass offsetted position ids when working with a KV-cache.
        unsqueeze_dim (`int`, *optional*, defaults to 1):
            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and
            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note
            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and
            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes
            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have
            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.
    Returns:
        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.
    """
    cos = cos[position_ids].unsqueeze(unsqueeze_dim) # BSND->BNSD
    sin = sin[position_ids].unsqueeze(unsqueeze_dim) # BSND->BNSD

    b, h, s, d = q.shape
    q = q.view(b, h, s, d // 2, 2).transpose(4, 3).reshape(b, h, s, d)

    b, h, s, d = k.shape
    k = k.view(b, h, s, d // 2, 2).transpose(4, 3).reshape(b, h, s, d)

    q_embed = (q * cos) + (rotate_half(q) * sin)
    k_embed = (k * cos) + (rotate_half(k) * sin)
    return q_embed, k_embed


def npu_apply_rotary_pos_emb(q, k, cos, sin, position_ids, layer_idx):
    b, h, s, d = q.shape
    q = q.view(b, h, s, d // 2, 2).transpose(4, 3).reshape(b, h, s, d)
    q = q.transpose(1, 2) # BSND

    b, h, s, d = k.shape
    k = k.view(b, h, s, d // 2, 2).transpose(4, 3).reshape(b, h, s, d)
    k = k.transpose(1, 2) # BSND

    q_embed, k_embed = torch_npu.npu_apply_rotary_pos_emb(q, k, cos, sin, layout="BSH")

    q_embed = q_embed.transpose(1, 2)
    k_embed = k_embed.transpose(1, 2)
    return q_embed, k_embed


class Qwen3MoeMLP(nn.Module):
    def __init__(self, config, hidden_size=None, intermediate_size=None):
        super().__init__()
        self.config = config
        self.world_size = int(os.getenv("WORLD_SIZE", "1"))
        self.num_experts = config.num_experts

        self.hidden_size = config.hidden_size if hidden_size is None else hidden_size
        self.intermediate_size = (
            config.intermediate_size if intermediate_size is None else intermediate_size
        )
        self.intermediate_size_per_rank = self.intermediate_size // self.world_size

        self.act_fn = ACT2FN[config.hidden_act]

        self.group_w1_w3 = nn.Parameter(
            torch.ones(self.num_experts, self.intermediate_size_per_rank * 2, self.hidden_size),
            requires_grad=False)
        self.group_w2 = nn.Parameter(
            torch.ones(self.num_experts, self.hidden_size, self.intermediate_size_per_rank),
            requires_grad=False)

    def forward(self, hidden_states, expert_tokens, seq_len=None):
        mm1_mm3 = torch_npu.npu_grouped_matmul([hidden_states], [self.group_w1_w3.transpose(1, 2)],
            group_list=expert_tokens, split_item=3, group_type=0)[0]
        intermediate_hidden_states = torch_npu.npu_swiglu(mm1_mm3)
        hidden_states = torch_npu.npu_grouped_matmul([intermediate_hidden_states], [self.group_w2.transpose(1, 2)],
            group_list=expert_tokens, split_item=3, group_type=0)[0]
        return hidden_states


class MoEGate(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.config = config
        self.top_k = config.num_experts_per_tok
        self.num_experts = config.num_experts

        self.batch_size = int(os.getenv("BATCH_SIZE", "1"))
        # topk selection algorithm
        self.norm_topk_prob = config.norm_topk_prob
        self.gating_dim = config.hidden_size
        self.weight = nn.Parameter(
            torch.empty((self.num_experts, self.gating_dim))
        )
        self.reset_parameters()

    def reset_parameters(self) -> None:
        pass

    def one_hot(self, tensor):
        index = torch.arange(0, self.n_group, dtype=tensor.dtype, device=tensor.device)
        return (
            tensor.view([*tensor.shape, 1]) == index.view([1] * tensor.ndim + [self.n_group])
        ).to(torch.float32)
    
    def forward_group_limited_greedy(self, logits):
        bs_seq, h = logits.shape
        scores = logits.softmax(dim=-1, dtype=torch.float32)
        group_scores = (
            scores.view(bs_seq, self.n_group, -1).max(dim=-1).values
        ) # [n, n_group]

        group_idx = torch.topk(
            group_scores, k=self.topk_group, dim=-1
        )[1]
        group_mask = self.one_hot(group_idx)
        group_mask = torch.sum(group_mask, dim=-1)
        score_mask = (
            group_mask.unsqueeze(-1).expand(
                bs_seq, self.n_group, self.num_experts // self.n_group
            ).reshape(bs_seq, -1)
        )
        tmp_scores = scores.masked_fill(~score_mask.bool(), 0.0)
        topk_weight, topk_idx = torch.topk(
            tmp_scores, k=self.top_k, dim=-1
        )
        row_idx = None
        return topk_idx, topk_weight, row_idx

    def forward_greedy(self, logits):
        topk_weight, topk_idx, row_idx = torch_npu.npu_moe_gating_top_k_softmax(logits, None, k=self.top_k)
        return topk_idx, topk_weight, row_idx

    def forward(self, hidden_states):
        bsz, seq_len, _ = hidden_states.shape
        hidden_states = hidden_states.view(-1, hidden_states.shape[-1])
        
        logits = F.linear(
            hidden_states, self.weight, None
        )
        topk_idx, topk_weight, row_idx = self.forward_greedy(logits)

        if self.top_k > 1 and self.norm_topk_prob:
            denominator = topk_weight.sum(dim=-1, keepdim=True) + 1e-20
            topk_weight = topk_weight / denominator
        else:
            topk_weight = topk_weight * self.routed_scaling_factor
        aux_loss = None
        return topk_idx, topk_weight, aux_loss, row_idx


class AddAuxiliaryLoss(torch.autograd.Function):
    """
    The trick function of adding auxiliary (aux) loss,
    which includes the gradient of the aux loss during backpropagation.
    """

    @staticmethod
    def forward(ctx, x, loss):
        assert loss.numel() == 1
        ctx.dtype = loss.dtype
        ctx.required_aux_loss = loss.requires_grad
        return x

    @staticmethod
    def backward(ctx, grad_output):
        grad_loss = None
        if ctx.required_aux_loss:
            grad_loss = torch.ones(1, dtype=ctx.dtype, device=grad_output.device)
        return grad_output, grad_loss


class Qwen3MoeSparseMoeBlockOri(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.num_experts = config.num_experts
        self.top_k = config.num_experts_per_tok
        self.norm_topk_prob = config.norm_topk_prob

        # gating
        self.gate = nn.Linear(config.hidden_size, config.num_experts, bias=False)
        self.experts = nn.ModuleList(
            [Qwen3MoeMLP(config, intermediate_size=config.moe_intermediate_size) for _ in range(self.num_experts)]
        )

    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:
        """ """
        batch_size, sequence_length, hidden_dim = hidden_states.shape
        hidden_states = hidden_states.view(-1, hidden_dim)
        # router_logits: (batch * sequence_length, n_experts)
        router_logits = self.gate(hidden_states)

        routing_weights = F.softmax(router_logits, dim=1, dtype=torch.float)
        routing_weights, selected_experts = torch.topk(routing_weights, self.top_k, dim=-1)
        if self.norm_topk_prob:  # only diff with mixtral sparse moe block!
            routing_weights /= routing_weights.sum(dim=-1, keepdim=True)
        # we cast back to the input dtype
        routing_weights = routing_weights.to(hidden_states.dtype)

        final_hidden_states = torch.zeros(
            (batch_size * sequence_length, hidden_dim), dtype=hidden_states.dtype, device=hidden_states.device
        )

        # One hot encode the selected experts to create an expert mask
        # this will be used to easily index which expert is going to be sollicitated
        expert_mask = torch.nn.functional.one_hot(selected_experts, num_classes=self.num_experts).permute(2, 1, 0)

        # Loop over all available experts in the model and perform the computation on each expert
        for expert_idx in range(self.num_experts):
            expert_layer = self.experts[expert_idx]
            idx, top_x = torch.where(expert_mask[expert_idx])

            # Index the correct hidden states and compute the expert hidden state for
            # the current expert. We need to make sure to multiply the output hidden
            # states by `routing_weights` on the corresponding tokens (top-1 and top-2)
            current_state = hidden_states[None, top_x].reshape(-1, hidden_dim)
            current_hidden_states = expert_layer(current_state) * routing_weights[top_x, idx, None]

            # However `index_add_` only support torch tensors for indexing so we'll use
            # the `top_x` tensor here.
            final_hidden_states.index_add_(0, top_x, current_hidden_states.to(hidden_states.dtype))
        final_hidden_states = final_hidden_states.reshape(batch_size, sequence_length, hidden_dim)
        return final_hidden_states, router_logits


class Qwen3MoeSparseMoeBlock(nn.Module):
    def __init__(self, config):
        super().__init__()
        self.config = config
        self.hidden_dim = config.hidden_size
        self.world_size = int(os.getenv("WORLD_SIZE", "1"))
        self.batch_size_decode = int(os.getenv("BATCH_SIZE", "1"))
        self.local_rank = int(os.getenv("LOCAL_RANK", "1"))
        self.input_len = int(os.getenv("INPUT_MAX_LEN", "2048"))
        self.dp_size = int(os.getenv("DP_SIZE", "1"))
        self.batch_size_prefill = 1
        self.npu_routing_kernel = _OPTIMIZER_SETTING["npu_routing_kernel"]
        self.num_experts_per_tok = config.num_experts_per_tok
        self.num_experts = config.num_experts
        self.top_k = config.num_experts_per_tok
        self.experts = Qwen3MoeMLP(config, intermediate_size=config.moe_intermediate_size)
        
        self.gate = MoEGate(config)
        if self.npu_routing_kernel:
            self.row_idx_decode_len = self.batch_size_decode * self.top_k
            self.row_idx_decode = torch.arange(
                0, self.row_idx_decode_len,
                dtype=torch.int32).view(self.top_k, -1).permute(1, 0).contiguous().npu()
        
    def forward(self, hidden_states):
        identity = hidden_states
        batch_size = hidden_states.shape[0]
        q_len = hidden_states.shape[1]

        topk_idx, topk_weight, _, row_idx = self.gate(hidden_states)
        if self.npu_routing_kernel:
            hidden_states_ordered_by_experts, routing_weights, expanded_row_idx, expert_idx \
                = self.moe_infer_fusion(hidden_states, topk_idx, topk_weight, row_idx)
            hidden_states = torch_npu.npu_moe_finalize_routing(
                hidden_states_ordered_by_experts, 
                skip1=None, skip2=None,
                bias=None,
                scales=routing_weights,
                expanded_src_to_dst_row=expanded_row_idx,
                export_for_source_row=expert_idx
            )
            y = hidden_states.view(batch_size, -1, self.hidden_dim)
        else:
            y = self.moe_infer_normal(hidden_states, topk_idx, topk_weight)
        return y
    
    def __one_hot(self, tensor, num_classes):
        index = torch.arange(0, num_classes, dtype=torch.float32, device=tensor.device)
        return (
            tensor.view([*tensor.shape, 1]) == index.view([1] * tensor.ndim + [num_classes])
        ).to(torch.float32)
    
    def __get_idx_info(self, selected_experts):
        # input_shape: selected_experts --> [bs*seq, topk]
        selected_experts = selected_experts.view(-1)
        selected_experts_fp32 = selected_experts.to(torch.int32).to(torch.float) # [bs*seq*topk]

        # get expert_cumsum mask
        # expert_mask shape is [bs*seq*topk, expert_num]
        expert_mask = self.__one_hot(selected_experts_fp32, num_classes=self.experts_per_rank)
        # expert_tokens shape is [expert_num, ], represent token_num performed by expert_i
        expert_tokens = torch.sum(expert_mask, dim=0)
        expert_tokens = torch.cumsum(expert_tokens, dim=0).to(torch.int64)

        # get sorted / unsort indices
        _, sorted_indices = torch.sort(selected_experts_fp32, dim=-1)
        sorted_indices_fp32 = sorted_indices.to(torch.int32).to(torch.float)
        _, unsort_indices = torch.sort(sorted_indices_fp32, dim=-1)
        return expert_tokens, sorted_indices, unsort_indices

    def moe_infer_normal(self, x, topk_ids, topk_weight):
        orig_shape = x.shape
        x = x.view(-1, x.shape[-1])

        topk_weight = topk_weight.to(x.dtype)
        expert_tokens, sorted_indices, unsort_indices = self.__get_idx_info(topk_ids)

        # get hid states
        hidden_states = x[:, None, ...].repeat((1, self.top_k, 1)).view((-1, x.shape[-1])) # [bs*seq*topk, hidden_size]
        hidden_states_sorted_by_experts = torch.index_select(hidden_states, 0, sorted_indices)

        # hidden_states_sorted_by_experts shape is [bs*seq*topk, hidden_size]
        hidden_states_sorted_by_experts = self.experts(
            hidden_states_sorted_by_experts, expert_tokens, seq_len=orig_shape[1])

        # hidden_states shape is [bs*seq*topk, hidden_size]
        hidden_states = torch.index_select(hidden_states_sorted_by_experts, 0, unsort_indices)
        # hidden_states shape is [bs*seq, topk, hidden_size]
        hidden_states = hidden_states.view(-1, self.top_k, x.shape[-1])
        # hidden_states shape is [bs*seq, topk, hidden_size]
        hidden_states = hidden_states * topk_weight.unsqueeze(-1)
        # hidden_states shape is [bs*seq, hidden_size]
        hidden_states = torch.sum(hidden_states, dim=1)

        hidden_states = hidden_states.view(*orig_shape)
        return hidden_states

    def moe_infer_fusion(self, x, topk_ids, topk_weight, row_idx):
        batch_size, sequence_length, h = x.shape
        hidden_states = x.view(-1, h)

        routing_weights = topk_weight.to(x.dtype)
        expert_idx = topk_ids.int()
        if row_idx is None:
            if sequence_length == 1:
                row_idx = self.row_idx_decode
            else:
                row_idx_prefill_len = self.batch_size_prefill * sequence_length * self.top_k
                row_idx_prefill = torch.arange(
                    0, row_idx_prefill_len, dtype=torch.int32,
                    device=topk_weight.device).view(self.top_k, -1).permute(1, 0).contiguous()
                row_idx = row_idx_prefill

        active_num = batch_size * sequence_length
        expanded_x, expanded_row_idx, expanded_expert_idx = torch_npu.npu_moe_init_routing(
            hidden_states,
            row_idx=row_idx,
            expert_idx=expert_idx,
            active_num=batch_size*sequence_length
        )
        expert_tokens = torch_npu.npu_moe_compute_expert_tokens(expanded_expert_idx, self.num_experts)
        expert_tokens = expert_tokens.to(torch.int64)

        hidden_states_ordered_by_experts = self.experts(expanded_x, expert_tokens, seq_len=sequence_length)

        return hidden_states_ordered_by_experts, routing_weights, expanded_row_idx, expert_idx
        

# Copied from transformers.models.llama.modeling_llama.repeat_kv
def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:
    """
    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,
    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)
    """
    batch, num_key_value_heads, slen, head_dim = hidden_states.shape
    if n_rep == 1:
        return hidden_states
    hidden_states = hidden_states[:, :, None, :, :].expand(
        batch, num_key_value_heads, n_rep, slen, head_dim
    )
    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)


def _init_rope(self):
    if self.config.rope_scaling is None:
        self.rotary_emb = Qwen3MoeRotaryEmbedding(
            self.config,
            self.config.head_dim,
            max_position_embeddings=self.config.max_position_embeddings,
            base=self.config.rope_theta,
        )
    else:
        scaling_type = self.config.rope_scaling["type"]
        scaling_factor = self.config.rope_scaling["factor"]
        if scaling_type == "linear":
            self.rotary_emb = Qwen3MoeLinearScalingRotaryEmbedding(
                self.config,
                self.config.head_dim,
                max_position_embeddings=self.config.max_position_embeddings,
                scaling_factor=scaling_factor,
                base=self.config.rope_theta,
            )
        elif scaling_type == "dynamic":
            self.rotary_emb = Qwen3MoeDynamicNTKScalingRotaryEmbedding(
                self.config,
                self.config.head_dim,
                max_position_embeddings=self.config.max_position_embeddings,
                scaling_factor=scaling_factor,
                base=self.config.rope_theta,
            )
        elif scaling_type == "yarn":
            kwargs = {
                key: self.config.rope_scaling[key]
                for key in [
                    "original_max_position_embeddings",
                    "beta_fast",
                    "beta_slow",
                    "mscale",
                    "mscale_all_dim",
                ]
                if key in self.config.rope_scaling
            }
            self.rotary_emb = Qwen3MoeYarnRotaryEmbedding(
                self.config,
                self.config.head_dim,
                max_position_embeddings=self.config.max_position_embeddings,
                scaling_factor=scaling_factor,
                base=self.config.rope_theta,
                **kwargs,
            )
        else:
            raise ValueError(f"Unknown RoPE scaling type {scaling_type}")


# Copied from transformers.models.llama.modeling_llama.LlamaAttention with Llama->Qwen3Moe
class Qwen3MoeAttention(nn.Module):
    """Multi-headed attention from 'Attention Is All You Need' paper"""

    def __init__(self, config, layer_idx: Optional[int] = None):
        super().__init__()
        self.world_size = int(os.getenv("WORLD_SIZE", "1"))
        self.config = config
        self.layer_idx = layer_idx
        if layer_idx is None:
            logger.warning_once(
                f"Instantiating {self.__class__.__name__} without passing `layer_idx` is not recommended and will "
                "to errors during the forward call, if caching is used. Please make sure to provide a `layer_idx` "
                "when creating this class."
            )

        self.attention_dropout = config.attention_dropout
        self.hidden_size = config.hidden_size
        self.hidden_size_per_rank = self.hidden_size // self.world_size
        self.num_heads = config.num_attention_heads
        self.num_heads_per_rank = self.num_heads // self.world_size
        self.head_dim = config.head_dim
        self.num_key_value_heads = config.num_key_value_heads
        self.num_key_value_heads_per_rank = max(self.num_key_value_heads // self.world_size, 1)
        self.num_key_value_groups = self.num_heads // self.num_key_value_heads

        self.max_position_embeddings = config.max_position_embeddings
        self.rope_theta = config.rope_theta

        self.is_causal = True

        self.attention_dropout = config.attention_dropout
        self.attn_intermediate_size = self.head_dim * self.num_heads
        self.attn_intermediate_size_per_rank = self.attn_intermediate_size // self.world_size

        self.merged_qkv_proj = nn.Linear(
            self.hidden_size, self.num_heads_per_rank * self.head_dim + \
                (self.num_key_value_heads_per_rank * self.head_dim) * 2, bias=False
        )
        self.q_norm = Qwen3MoeRMSNorm(self.head_dim, eps=config.rms_norm_eps)
        self.k_norm = Qwen3MoeRMSNorm(self.head_dim, eps=config.rms_norm_eps)

        
        self.batch_size = int(os.getenv("BATCH_SIZE", "1"))
        self.input_len = int(os.getenv("INPUT_MAX_LEN", "2048"))

        self.o_proj = nn.Linear(self.attn_intermediate_size_per_rank, self.hidden_size, bias=False)
        if self.world_size > 1:
            self.commute_type = "all_reduce"
        else:
            self.commute_type = "no_commute"

        self.scale_fa = 1 / (self.head_dim ** 0.5)

    def _shape(self, tensor: torch.Tensor, seq_len: int, bsz: int):
        return (
            tensor.view(bsz, seq_len, self.num_heads, self.head_dim)
            .transpose(1, 2)
            .contiguous()
        )

    def exec_qkv(
        self,
        qkv: torch.Tensor,
        kv_len: torch.IntTensor = None,
        actual_seq_lengths_kv: list = None,
        cos_sin: Optional[Tuple[torch.Tensor]] = None,
        attention_mask: Optional[torch.Tensor] = None,
        position_ids: Optional[torch.LongTensor] = None,
        past_key_value: Optional[Cache] = None,
        **kwargs,
    ):
        bsz, q_len, _ = qkv.size()

        query_states, key_states, value_states = qkv.split((self.num_heads_per_rank * self.head_dim, \
                                                            self.num_key_value_heads_per_rank * self.head_dim, \
                                                            self.num_key_value_heads_per_rank * self.head_dim), dim=2)
        
        query_shape = (bsz, q_len, self.num_heads_per_rank, self.head_dim)
        key_value_shape = (bsz, q_len, self.num_key_value_heads_per_rank, self.head_dim)

        query_states = self.q_norm(query_states.view(query_shape).contiguous())
        key_states = self.k_norm(key_states.view(key_value_shape).contiguous())

        cos, sin = cos_sin
        query_states, key_states = torch_npu.npu_apply_rotary_pos_emb(query_states, key_states, cos, sin, layout='BSH')
        query_states = query_states.view(bsz, q_len, -1)
        key_states = key_states.view(bsz, q_len, -1)

        past_key, past_value = None, None
        if past_key_value is not None:
            past_key = past_key_value[self.layer_idx][0]
            past_value = past_key_value[self.layer_idx][1]
            torch_npu.scatter_update_(past_key, kv_len, key_states, -2)
            torch_npu.scatter_update_(past_value, kv_len, value_states, -2)

        if q_len == 1:
            past_key_states, past_value_states = past_key_value[self.layer_idx]

            attn_output, _ = torch.ops.npu.npu_fused_infer_attention_score(
                query_states, past_key_states, past_value_states,
                num_heads=self.num_heads_per_rank,
                num_key_value_heads=self.num_key_value_heads_per_rank,
                input_layout="BSH",
                atten_mask=attention_mask,
                scale=self.scale_fa,
                actual_seq_lengths_kv=actual_seq_lengths_kv,
                antiquant_mode=0, antiquant_scale=None
            )
        else:
            attn_output, _ = torch.ops.npu.npu_fused_infer_attention_score(
                query_states, key_states, value_states,
                num_heads=self.num_heads_per_rank,
                num_key_value_heads=self.num_key_value_heads_per_rank,
                input_layout="BSH",
                atten_mask=attention_mask,
                sparse_mode=2,
                scale=self.scale_fa,
                next_tokens=0
            )

        attn_output = attn_output.reshape(bsz, q_len, self.attn_intermediate_size_per_rank)
        attn_output = self.o_proj(attn_output)

        if self.commute_type == "all_reduce":
            dist.all_reduce(attn_output)
        else:
            attn_output = attn_output
        
        return attn_output

    def forward(
        self,
        hidden_states: torch.Tensor,
        kv_len: torch.IntTensor = None,
        actual_seq_lengths_kv: list = None,
        cos_sin: torch.Tensor = None,
        attention_mask: Optional[torch.Tensor] = None,
        position_ids: Optional[torch.LongTensor] = None,
        past_key_value: Optional[Cache] = None,
        output_attentions: bool = False,
        use_cache: bool = False,
        **kwargs,
    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:
        if "padding_mask" in kwargs:
            warnings.warn(
                "Passing `padding_mask` is deprecated and will be removed in v4.37. Please make sure use `attention_mask` instead.`"
            )
        bsz, q_len, _ = hidden_states.size()
        qkv = self.merged_qkv_proj(hidden_states)
        output = self.exec_qkv(
            qkv=qkv,
            kv_len=kv_len,
            actual_seq_lengths_kv=actual_seq_lengths_kv,
            cos_sin=cos_sin,
            attention_mask=attention_mask,
            position_ids=position_ids,
            past_key_value=past_key_value
        )
        return output
    
ATTENTION_CLASSES = {
    "eager": Qwen3MoeAttention,
}


class Qwen3MoeDecoderLayer(nn.Module):
    def __init__(self, config: Qwen3MoeConfig, layer_idx: int):
        super().__init__()
        self.world_size = int(os.getenv("WORLD_SIZE", "1"))
        self.hidden_size = config.hidden_size

        self.self_attn = Qwen3MoeAttention(
            config=config, layer_idx=layer_idx
        )

        if _OPTIMIZER_SETTING["npu_gmm"]:
            moe_class = Qwen3MoeSparseMoeBlock
        else:
            moe_class = Qwen3MoeSparseMoeBlockOri
        
        self.layer_idx = layer_idx

        self.mlp = (
            moe_class(config)
        )
        self.input_layernorm = Qwen3MoeRMSNorm(
            config.hidden_size, eps=config.rms_norm_eps
        )
        self.post_attention_layernorm = Qwen3MoeRMSNorm(
            config.hidden_size, eps=config.rms_norm_eps
        )

        self.batch_size = int(os.getenv("BATCH_SIZE", "1"))
        self.input_len = int(os.getenv("INPUT_MAX_LEN", "2048"))

    def forward(
        self,
        hidden_states: torch.Tensor,
        kv_len: torch.IntTensor,
        actual_seq_lengths_kv: list,
        cos_sin: torch.Tensor,
        attention_mask: Optional[torch.Tensor] = None,
        position_ids: Optional[torch.LongTensor] = None,
        past_key_value: Optional[Tuple[torch.Tensor]] = None,
        output_attentions: Optional[bool] = False,
        use_cache: Optional[bool] = False,
        past_residual: Optional[torch.Tensor] = None,
        **kwargs,
    ) -> Tuple[torch.FloatTensor]:
        
        bsz, q_len, _ = hidden_states.size()
        reduce_flag = False
        if self.layer_idx == 0:
            reduce_flag = False
        else:
            reduce_flag = True
        
        if reduce_flag and self.world_size > 1:
            dist.all_reduce(hidden_states)
        
        hidden_states, residual = self.input_layernorm(hidden_states, past_residual)

        qkv = self.self_attn.merged_qkv_proj(hidden_states)

        # Self Attention
        hidden_states = self.self_attn.exec_qkv(
            qkv=qkv,
            kv_len=kv_len,
            actual_seq_lengths_kv=actual_seq_lengths_kv,
            cos_sin=cos_sin,
            attention_mask=attention_mask,
            position_ids=position_ids,
            past_key_value=past_key_value,
        )

        # Fully Connected
        hidden_states, residual = self.post_attention_layernorm(hidden_states, residual)
        hidden_states = self.mlp(hidden_states)

        outputs = (residual, hidden_states)
        return outputs


Qwen3Moe_START_DOCSTRING = r"""
    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the
    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
    etc.)

    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.
    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
    and behavior.

    Parameters:
        config ([`Qwen3MoeConfig`]):
            Model configuration class with all the parameters of the model. Initializing with a config file does not
            load the weights associated with the model, only the configuration. Check out the
            [`~PreTrainedModel.from_pretrained`] method to load the model weights.
"""


@add_start_docstrings(
    "The bare Qwen3Moe Model outputting raw hidden-states without any specific head on top.",
    Qwen3Moe_START_DOCSTRING,
)
class Qwen3MoePreTrainedModel(PreTrainedModel):
    config_class = Qwen3MoeConfig
    base_model_prefix = "model"
    supports_gradient_checkpointing = True
    _no_split_modules = ["Qwen3MoeDecoderLayer"]
    _skip_keys_device_placement = "past_key_values"
    _supports_flash_attn_2 = True
    _supports_cache_class = True

    def _init_weights(self, module):
        pass


Qwen3Moe_INPUTS_DOCSTRING = r"""
    Args:
        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):
            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide
            it.

            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and
            [`PreTrainedTokenizer.__call__`] for details.

            [What are input IDs?](../glossary#input-ids)
        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):
            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:

            - 1 for tokens that are **not masked**,
            - 0 for tokens that are **masked**.

            [What are attention masks?](../glossary#attention-mask)

            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and
            [`PreTrainedTokenizer.__call__`] for details.

            If `past_key_values` is used, optionally only the last `input_ids` have to be input (see
            `past_key_values`).

            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]
            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more
            information on the default strategy.

            - 1 indicates the head is **not masked**,
            - 0 indicates the head is **masked**.
        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):
            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,
            config.n_positions - 1]`.

            [What are position IDs?](../glossary#position-ids)
        past_key_values (`Cache` or `tuple(tuple(torch.FloatTensor))`, *optional*):
            Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention
            blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`
            returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.

            Two formats are allowed:
            - a [`~cache_utils.Cache`] instance;
            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of
            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy
            cache format.

            The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the
            legacy cache format will be returned.

            If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't
            have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`
            of shape `(batch_size, sequence_length)`.
        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):
            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This
            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the
            model's internal embedding lookup matrix.
        use_cache (`bool`, *optional*):
            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see
            `past_key_values`).
        output_attentions (`bool`, *optional*):
            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned
            tensors for more detail.
        output_hidden_states (`bool`, *optional*):
            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for
            more detail.
        return_dict (`bool`, *optional*):
            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.
"""


@add_start_docstrings(
    "The bare Qwen3Moe Model outputting raw hidden-states without any specific head on top.",
    Qwen3Moe_START_DOCSTRING,
)
class Qwen3MoeModel(Qwen3MoePreTrainedModel):
    """
    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`Qwen3MoeDecoderLayer`]

    Args:
        config: Qwen3MoeConfig
    """

    def __init__(self, config: Qwen3MoeConfig):
        super().__init__(config)
        self.config = config
        self.rank_id = int(os.getenv("LOCAL_RANK", "0"))
        self.world_size = int(os.getenv("WORLD_SIZE", "1"))
        self.padding_idx = config.pad_token_id
        self.vocab_size = config.vocab_size
        self.vocab_size_per_rank = self.vocab_size // self.world_size

        self.embed_tokens = nn.Embedding(
            self.vocab_size_per_rank, config.hidden_size, self.padding_idx
        )
        self.layers = nn.ModuleList(
            [
                Qwen3MoeDecoderLayer(config, layer_idx)
                for layer_idx in range(config.num_hidden_layers)
            ]
        )
        self.norm = Qwen3MoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)
        self.gradient_checkpointing = False
        # Initialize weights and apply final processing
        self.post_init()
        _init_rope(self)

    def get_input_embeddings(self):
        return self.embed_tokens

    def set_input_embeddings(self, value):
        self.embed_tokens = value

    @add_start_docstrings_to_model_forward(Qwen3Moe_INPUTS_DOCSTRING)
    def forward(
        self,
        input_ids: torch.LongTensor,
        kv_len: torch.IntTensor = None,
        actual_seq_lengths_kv: list = None,
        attention_mask: Optional[torch.Tensor] = None,
        position_ids: Optional[torch.LongTensor] = None,
        past_key_values: Optional[List[torch.FloatTensor]] = None,
        inputs_embeds: Optional[torch.FloatTensor] = None,
        use_cache: Optional[bool] = True,
        output_attentions: Optional[bool] = False,
        output_hidden_states: Optional[bool] = None,
        return_dict: Optional[bool] = None
    ):
        
        batch_size, seq_length = input_ids.shape
        past_key_values_length = past_key_values[0][0].size()[-2]

        if position_ids is None:
            device = input_ids.device
            position_ids = torch.arange(
                past_key_values_length, seq_length + past_key_values_length, dtype=torch.long, device=device
            )
            position_ids = position_ids.unsqueeze(0).view(-1, seq_length)
        else:
            position_ids = position_ids.view(-1, seq_length).long()

        if self.world_size > 1:
            new_input_ids = input_ids - self.rank_id * self.vocab_size_per_rank
            mask = (new_input_ids >= 0) & (new_input_ids < self.vocab_size_per_rank) # (bs, qlen)
            new_input_ids_per_rank = new_input_ids * mask
            inputs_embeds = self.embed_tokens(new_input_ids_per_rank) * mask.unsqueeze(-1)
            dist.all_reduce(inputs_embeds)
        else:
            inputs_embeds = self.embed_tokens(input_ids)
        hidden_states = inputs_embeds

        cos_sin = self.rotary_emb(hidden_states, seq_length, kv_len, self.config.max_position_embeddings)
        residual = None

        for decoder_layer in self.layers:
            layer_outputs = decoder_layer(
                hidden_states,
                kv_len,
                actual_seq_lengths_kv,
                cos_sin=cos_sin,
                attention_mask=attention_mask,
                position_ids=position_ids,
                past_key_value=past_key_values,
                past_residual=residual
            )
            residual, hidden_states = layer_outputs

        if self.world_size > 1:
            dist.all_reduce(hidden_states)

        hidden_states, _ = self.norm(hidden_states, residual)

        return hidden_states


class Qwen3MoeForCausalLM(Qwen3MoePreTrainedModel):
    _tied_weights_keys = ["lm_head.weight"]

    def __init__(self, config):
        super().__init__(config)
        config.num_hidden_layers = int(os.getenv("LAYER_NUM", "94"))
        self.config = config
        self.input_max_len = int(os.getenv("INPUT_MAX_LEN", 1024))
        self.world_size = int(os.getenv("WORLD_SIZE", "1"))
        self.model = Qwen3MoeModel(config)
        self.vocab_size = config.vocab_size
        self.world_size = int(os.getenv("WORLD_SIZE", "1"))
        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size // self.world_size, bias=False)

        # Initialize weights and apply final processing
        self.post_init()

    def get_input_embeddings(self):
        return self.model.embed_tokens

    def set_input_embeddings(self, value):
        self.model.embed_tokens = value

    def get_output_embeddings(self):
        return self.lm_head

    def set_output_embeddings(self, new_embeddings):
        self.lm_head = new_embeddings

    def set_decoder(self, decoder):
        self.model = decoder

    def get_decoder(self):
        return self.model

    def forward(
        self,
        input_ids: torch.LongTensor = None,
        kv_len: torch.IntTensor = None,
        actual_seq_lengths_kv: list = None,
        attention_mask: Optional[torch.Tensor] = None,
        position_ids: Optional[torch.LongTensor] = None,
        past_key_values: Optional[List[torch.FloatTensor]] = None,
        inputs_embeds: Optional[torch.FloatTensor] = None,
        labels: Optional[torch.LongTensor] = None,
        use_cache: Optional[bool] = None,
        output_attentions: Optional[bool] = None,
        output_hidden_states: Optional[bool] = None,
        return_dict: Optional[bool] = None
    ):
        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)
        outputs = self.model(
            input_ids=input_ids,
            kv_len=kv_len,
            actual_seq_lengths_kv=actual_seq_lengths_kv,
            attention_mask=attention_mask,
            position_ids=position_ids,
            past_key_values=past_key_values
        )

        hidden_states = outputs

        if hidden_states.size()[1] > 1:
            gather_index, _ = torch.max(position_ids, dim=-1)
            gather_index = gather_index.unsqueeze(1).unsqueeze(2).repeat(1, 1, hidden_states.shape[-1])
            hidden_states = torch.gather(hidden_states, 1, gather_index)

        logits = self.lm_head(hidden_states)
        if self.world_size > 1:
            new_logits = [logits.clone().detach() for _ in range(self.world_size)]
            dist.all_gather(new_logits, logits)
            logits = torch.concat(new_logits, dim=-1)
        logits = logits.float()

        return logits

    def init_cache(
        self,
        input_ids,
        world_size=1,
    ):
        batch_size, seq_len = input_ids.size()

        cache_seq_len = self.config.max_position_embeddings

        past_key_values = ()
        cache_shape = (
                        batch_size,
                        cache_seq_len,
                        self.config.head_dim * max(self.config.num_key_value_heads // self.world_size, 1)
                      )
        dtype = self.config.torch_dtype

        for i in range(self.config.num_hidden_layers):
            key_cache = torch.zeros(cache_shape, dtype=dtype, device=input_ids.device)
            value_cache = torch.zeros(cache_shape, dtype=dtype, device=input_ids.device)
            past_key_values += ((key_cache, value_cache),)

        return past_key_values

    def prepare_inputs_for_generation(
        self,
        input_ids,
        past_key_values=None,
        attention_mask=None,
        inputs_embeds=None,
        is_prefill=None,
        kv_len=None,
        share_mask_tril=None,
        world_size=1,
        **kwargs   
    ):
        batch_size, seq_len = input_ids.size()
        if past_key_values is None:
            past_key_values = self.init_cache(input_ids, world_size)
        if is_prefill:
            position_ids = attention_mask.long().cumsum(-1) - 1
            position_ids.masked_fill_(attention_mask == 0, 1)
            attention_mask = share_mask_tril
            kv_len = torch.zeros((position_ids.size()[0]), dtype=torch.int32, device=input_ids.device)
            actual_seq_lengths_kv = None
        else:
            attention_mask = None
            position_ids = kv_len.unsqueeze(1)
            if int(os.getenv("ENABLE_PROFILE", "0")):
                actual_seq_lengths_kv = [int(os.getenv("INPUT_MAX_LEN", 1024)),] * kv_len.size()[0]
            else:
                actual_seq_lengths_kv = (kv_len + 1).cpu().detach().numpy().tolist()

        model_inputs = {}
        model_inputs.update(
            {
                "input_ids": input_ids,
                "position_ids": position_ids,
                "past_key_values": past_key_values,
                "attention_mask": attention_mask,
                "kv_len": kv_len,
                "actual_seq_lengths_kv": actual_seq_lengths_kv
            }
        )
        return model_inputs

    @staticmethod
    def _reorder_cache(past_key_values, beam_idx):
        reordered_past = ()
        for layer_past in past_key_values:
            reordered_past += (
                tuple(
                    past_state.index_select(0, beam_idx.to(past_state.device))
                    for past_state in layer_past
                ),
            )
        return reordered_past
